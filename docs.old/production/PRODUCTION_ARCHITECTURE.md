# Symmetra Production Architecture: AI + Vector Database Hybrid

## The Core Problem We're Solving

When Claude Code provides architectural guidance, developers want advice that follows their specific team standards, not generic best practices. A startup using Firebase doesn't want guidance about PostgreSQL connection pooling. A team that standardized on Redux doesn't want suggestions to try Zustand. Symmetra solves this by storing team-specific architectural rules in a vector database and using AI to apply those rules contextually.

## How It Works in Practice

When a developer asks Claude Code for architectural guidance, Symmetra performs a three-step process. First, it runs deterministic checks for obvious problems like hardcoded secrets or clear anti-patterns that are universally bad. Second, it searches the vector database for rules that are semantically similar to the developer's request, filtered by their project context. Third, it uses AI to synthesize those specific rules into actionable guidance for the exact situation.

This means when a developer says "I need to implement user authentication," Symmetra doesn't give generic OAuth advice. Instead, it finds that team's specific authentication patterns, maybe their custom middleware or preferred libraries, and provides guidance that fits their existing architecture.

## The Technical Architecture

The system consists of three main components working together. The MCP server receives requests from Claude Code and orchestrates the response. The vector database stores team-specific rules with semantic embeddings that enable contextual search. The AI synthesis engine takes the retrieved rules and adapts them to the specific request.

The MCP server runs as a simple Python service that Claude Code communicates with through the Model Context Protocol. When a request comes in, the server validates the user's project access through Supabase's row-level security, ensuring teams only see their own rules plus any global best practices.

The vector database uses Supabase with the pgvector extension, which is already set up in our infrastructure. Rules are stored with 384-dimensional embeddings generated by the sentence-transformers library. Each rule includes not just the guidance text, but context about when it applies, which tech stacks it's relevant for, and examples of proper implementation.

The AI synthesis happens through carefully crafted prompts that take the retrieved rules and adapt them to the specific request. Instead of hallucinating generic advice, the AI is constrained to work within the team's established patterns while being flexible enough to handle novel situations.

## Data Flow and User Experience

A typical interaction starts when a developer is working in their IDE and asks Claude Code something like "How should I structure this API endpoint?" Claude Code sends this request to Symmetra along with the current code context and project information.

Symmetra first generates an embedding for the request and searches the vector database for semantically similar rules. The search is automatically filtered to rules that belong to the developer's project or are marked as global best practices. The system might find rules about the team's preferred error handling patterns, their API versioning strategy, or their database interaction conventions.

The AI synthesis engine then takes these specific rules and crafts guidance that addresses the exact question while staying within the team's established patterns. The response goes back to Claude Code, which presents it to the developer as contextual architectural advice.

The key insight is that this happens transparently. The developer doesn't need to remember to check a rules database or wonder if they're following team conventions. The guidance just appears when they need it, tailored to their specific situation but grounded in their team's decisions.

## Rule Management and Team Workflows

Teams populate their rule database through a combination of initial setup and ongoing curation. During onboarding, architectural decisions that are already established get codified as rules. This might include preferred libraries, coding patterns, deployment strategies, or security requirements.

Over time, teams add new rules as they make new architectural decisions. When the team decides to migrate from REST to GraphQL, they add rules about GraphQL best practices. When they adopt a new testing strategy, they document it as rules that will guide future development.

The vector database enables flexible rule discovery. Instead of requiring developers to navigate complex taxonomies or remember exact rule names, they can ask natural language questions and find relevant guidance. A question about "handling file uploads" might surface rules about S3 configuration, image processing pipelines, and security validation, even if those rules don't explicitly mention "file uploads."

## Integration with Existing Development Workflows

Symmetra integrates seamlessly with how teams already work. For teams using Claude Code, it appears as additional context that makes architectural guidance more relevant. For teams not yet using AI assistants, it provides a pathway to capture and share architectural knowledge that previously lived only in senior developers' heads.

The system respects project boundaries through Supabase's row-level security. A developer working on multiple projects automatically sees the appropriate rules for each context. Consultants working with different clients get guidance tailored to each client's specific requirements and constraints.

The MCP integration means Symmetra works with any tool that supports the Model Context Protocol, not just Claude Code. As the ecosystem evolves, the same rule database can power guidance in different development environments.

## Deployment and Operations

The production deployment leverages Supabase for the database layer and vector search capabilities. This provides managed PostgreSQL with pgvector, built-in authentication and authorization, and edge functions for the API layer. The vector embeddings are generated using sentence-transformers, which can run either locally during rule creation or as a batch process.

For teams starting out, the system includes bootstrap rules that provide sensible defaults for common architectural patterns. These global rules ensure teams get useful guidance even before they've customized the system for their specific needs. As teams mature their Symmetra usage, they can override global rules with more specific guidance that reflects their unique requirements.

The MCP server is designed to be lightweight and fast, since it needs to respond quickly to keep Claude Code conversations flowing smoothly. Rule retrieval is optimized through vector indexes, and the most common queries are designed to complete in under 100ms.

## Privacy and Security Considerations

Since Symmetra stores team-specific architectural knowledge, security is paramount. All rule access is governed by Supabase's row-level security policies, which ensure users can only access rules for projects they're authorized to work on. Authentication flows through standard JWT tokens, and all communication happens over HTTPS.

The vector embeddings don't contain sensitive information directly, but they could potentially be used to infer information about team practices. The system is designed so that embeddings and rule content are stored together and protected by the same access controls.

For teams with particularly sensitive requirements, the entire system can be deployed in their own cloud environment rather than using shared infrastructure. The Supabase deployment can be isolated, and the MCP server can run within their existing security boundaries.

## Evolution and Extensibility

The architecture is designed to evolve as both AI capabilities and team needs grow. The vector database can be enhanced with more sophisticated embeddings or different similarity metrics. The AI synthesis can be upgraded to use more powerful models or more nuanced prompting strategies.

The rule schema supports rich metadata that enables future capabilities. Rules can include confidence scores, usage statistics, or links to supporting documentation. The system can track which rules are most helpful and surface insights about architectural patterns that work well for specific types of projects.

As teams use Symmetra, they generate data about which architectural guidance is most valuable in practice. This creates opportunities for the system to learn and improve over time, suggesting new rules based on successful patterns or highlighting rules that might need updating based on changing technology landscapes.